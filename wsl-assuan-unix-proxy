#!/usr/bin/env python3
# Copyright 2018-2019  Simon Arlott
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

import argparse
import logging
import os
import signal
import socket
import sys


DEFAULT_LISTEN = os.path.join(os.environ["HOME"], ".gnupg", "S.gpg-agent")
DEFAULT_CONNECT = os.path.join("/mnt/c/Users", os.environ["USER"], "AppData", "Roaming", "gnupg", "S.gpg-agent")


def cleanup_socket(listen):
	try:
		os.unlink(listen)
	except FileNotFoundError:
		pass


def run(listen, connect):
	os.umask(0o0077)

	logging.info("Opening listening socket on " + listen)
	cleanup_socket(listen)
	linux = socket.socket(family=socket.AF_UNIX, type=socket.SOCK_STREAM)
	linux.bind(listen)
	linux.listen()
	logging.info("Listening on " + listen)
	os.set_inheritable(linux.fileno(), False)

	id = 0
	running = True
	while running:
		(client, address) = linux.accept()
		id += 1
		try:
			if os.fork() == 0:
				logging.info("Accepted connection " + str(id))
				running = False

				try:
					with open(connect, "rb") as f:
						lines = f.read().split(b"\n", 2)
						if len(lines) < 2:
							logging.error("File " + connect + " invalid: " + repr(lines))
						port = int(lines[0].decode("ascii"))
						token = lines[1]
				except FileNotFoundError as e:
					logging.error(e)
					return

				logging.info("Connecting to port " + str(port))
				with socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=socket.IPPROTO_TCP) as windows:
					try:
						windows.connect(("127.0.0.1", port))
					except socket.error as e:
						logging.error(e)
						return

					logging.debug("Sending token")
					windows.send(token)

					logging.debug("Bridging sockets")
					try:
						os.set_inheritable(client.fileno(), True)
						os.set_inheritable(windows.fileno(), True)
						os.execlp("socat", "socat", "fd:" + str(client.fileno()), "fd:" + str(windows.fileno()))
					except OSError as e:
						logging.error(e)
						return
		finally:
			client.close()


if __name__ == "__main__":
	logging.basicConfig(level=logging.INFO, format="%(asctime)-15s [%(process)10d] %(levelname)-7s %(message)s")

	parser = argparse.ArgumentParser(description="Windows Subsystem for Linux Assuan Unix Proxy")
	parser.add_argument("-l", "--listen", metavar="LISTEN_FILENAME", type=str, default=DEFAULT_LISTEN, help="Linux socket path [" + DEFAULT_LISTEN + "]")
	parser.add_argument("-c", "--connect", metavar="CONNECT_FILENAME", type=str, default=DEFAULT_CONNECT, help="Windows socket path [" + DEFAULT_CONNECT + "]")

	args = parser.parse_args()

	def sigterm_handler(signum, frame):
		cleanup_socket(args.listen)
		signal.signal(signal.SIGTERM, signal.SIG_DFL)
		os.kill(os.getpid(), signal.SIGTERM)
		sys.exit(1)

	signal.signal(signal.SIGTERM, sigterm_handler)

	try:
		run(args.listen, args.connect)
	finally:
		cleanup_socket(args.listen)
